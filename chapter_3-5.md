# 멀티 플레이어 게임 프로그래밍

# 3. 버클리 소켓

## 블로킹 I/O와 논블로킹I/O

- 소켓 관련 함수는 대부분 받을 데이터가 없을 때 스레드가 블로킹되어 데이터가 수실될 때 까지 기다려야 하는 블로킹 호출이다.

- 하지만 메인 스레드에서 패킷을 처리하려 한다면 이는 바람직하지 않다.
- 이를 해결할 수 있는 방법은 크게 3가지다.
    - 멀티스레딩
    - 논블로킹 I/O
    - select()

### 멀티스레딩

- 블로킹 가능성이 있는 함수의 호출을 별도의 스레드에서 수행하는 방법이다.

- 예시

    ![멀티스레딩 절차](/image/picture_3-1.png)

    그림 3-1) 멀티스레딩 절차

    - 구동 직후 리스닝 스레드는 소켓으로 만들고 바인딩 한 다음, 리스닝을 걸고 accept()를 호출한다.

    - accept()는 클라이언트가 접속하기 전까지 블로킹 상태에 빠진다.
    - 클라이언트가 접속하면 accept() 함수는 새 소켓을 리턴하고 복귀한다.
    - 서버 프로세스는 이제 새 소켓으로 스레드를 하나 더 만드는데, 이 스레드는 반복해서 recv를 호출한다,
    - recv()함수는 클라이언트가 데이터를 보내기 전까지 블로킹 된다.
    - 클라이언트가 데이터를 보내면 recv가 블로킹 상태를 빠져나와 스레드 수행을 재개하며, 일종의 콜백 메커니즘으로 수신된 데이터를 메인 스레드에 보내준 다음 루프를 재개하면 recv)()를 또 호출한다.
    - 그동안 리스닝 소켓은 또 자신만의 블로킹 상태에서 다른 접속을 기다린다.
    - 이리하여 메인 스레드는 원활하게 게임 시뮬레이션을 수행할 수 있다.
- 장점
    - 블로킹으로 인한 딜레이를 어느정도 극복할 수 있다.

- 단점 
    - 클라이언트당 하나씩 스레드를 할당 해야 한다.
    
    - 데이터가 병렬적으로 한꺼번에 여러 스레드에 들어올 수 있어 메인 스레드로 전달하기 까다롭다.
