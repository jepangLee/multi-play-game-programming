# 멀티 플레이어 게임 프로그래밍

# 3. 버클리 소켓

## TCP 소켓

- UDP와는 달리 신뢰성을 보장하며, 연결을 맺은 상태를 유지해야 한다. 즉, 호스트가 각 TCP 연결마다 별개의 독자적 소켓을 하나씩 유지해야 한다.

- 클라이언트아 서버 사이에 연결을 초기 수립하려면 3-웨이 핸드셰이킹을 거쳐야 한다.

### listen()


- 소켓 생성과 바인딩 이후에 바로 해당 함수부터 시작된다.

        int listen(SOCKET sock, int backlog);

    - sock
        - 리스닝 모드에 둘 소켓을 가리킨다.
        - 리스닝 모드에 있으면 외부에서 들어오는 TCP 핸드셰이킹 첫 단계 요청을 받아 이를 대기열에 저장해 둔다.
        - 이후 프로세스가 accept()를 호출하면 저장해 둔 연결 요청에 다음 핸드셰이킹 단계로 넘어간다.
    - backlog
        - 대기열에 연결이 들어오는 것을 둘 최대 개수를 지정한다.
        - 대기열이 가득차면 이 후로 들어오려는 연결은 끊어진다.
        - 기본값 메크로는 SOMAXCONN이다.
    - 출력
        - 성공 : 0
        - 실패 : -1
    
### accept()

- listen()함수가 리스닝 모드로 둔 소켓을 기반으로 원격 호스트와 통신이 가능한 새로운 소켓을 만드는 기능을 수행한다.

        SOCKET accept(SOCKET sock, sockaddr* addr, int*addrlen);

    - sock : 리스닝 모드의 소켓으로, 여기서 들어오는 요청을 받게 된다.
    - addr 
        - 해당 함수가 연결을 요청하는 원격 호스트의 주소를 채워줄 sockaddr 구조체 포인터이다.
        - 오로지 수락된 연결의 주소를 받는 용도로만 사용된다.
    - addrlen
        - addr 버퍼의 포인터 길이를 리턴하는 용도로 사용된다.
        - addr 내용이 채워질 때만 그 길이가 해당변수 채워진다.
    - 리턴
        - 원격 호스트와 통신이 가능한 소켓
            - 해당 소켓은 리스닝 소켓과 같은 포트로 바인딩된다.

### connect()

- accept()가 리턴한 소켓을 이용하여 원격 서버에 접속하고, 핸드셰이킹 절차를 시작하게 된다.

        int connect(SOCKET sock, const sockaddr* addr, int addrlen);

    - sock : 연결에 사용하고자 하는 소켓이다,
    
    - addr : 연결하고자 하는 원격 호스트의 주소를 가리키는 포인터이다.
    - addrlen : addr의 길이이다.
    - 리턴값 
        - 성공 : 0
        - 실패 : -1

- 해당 함수를 호출하면 최초 SYN패킷을 대상 호스트에 정송하여 TCP 행드셰이킹을 개시한다.
- 원격 호스트에 해당 포트로 바인딩한 리스닝 모드 소켓이 있을 결우, 서버 원격 호스트는 accept()를 호출하여 이 핸드셰이킹을 처리한다,
- 별다른 옵션이 없다면 해당 함수 호출시 호출 스레드는 연결이 수락되거나 초과할 때까지 블로킹된다.

### send()

- 연결된 TCP 소켓을 이용해 데이터를 전송하는 함수다.

        int send(SOCKET sock, const char* buf, int len, int flags);

    - sock : 데이터를 전송하는 데 사용할 소켓이다.
    - buf
        - 스트림에 기록할 데이터가 담긴 버퍼이다.
        - UDP와는 달리 한 번에 전송된다는 보장이 없어서 소켓의 외부 전송전용 버퍼에 추가되었다가 이후 소켓 라이브러리에 의해 적당한 시기에 전송된다.
        - 최대 세그먼트 길이를 가득 채우기 전까지 전송되지 않는다.
    - len
        - 전송할 데이터의 바이트 수이다.
        - UDP와는 달리 MTU보다 작게 잡을 필요가 없다.
        - 소켓의 전송 버퍼에 자리가 있는 한 네트워크 라이브러리는 데이터를 모두 보낼 수 있으며, 이를 위해 데이터를 적당한 크기의 덩어리로 잘라서 보내게 될 것이다.
    - flags : 데이터 전송을 제어하는 비트 플래그이다.
    - 리턴값 
        - 성공 
            - 전송 성공한 데이터의 길이
            - 만일 len보다 작다면 소켓의 전송 버퍼가 전부 보내기에는 모자라서 여우 공간 만큼 잘라 보냈다는 뜻이다. 남은 데이터는 대기열에 등록되어 있다고 생각하면 된다.
        - 실패 : -1

### recv()

- 연결된 TCP 소켓을 이용해 데이터를 받는 함수다.

        int recv(SOCKET sock, char* buf, int len, int flags);

    - sock : 데이터를 수신하는데 사용할 소켓이다.
    - buf 
        - 데이터를 복사해 넣을 버퍼를 가리킨다.
        - 데이터를 복사하고 나면 해당 데이터는 소켓 내부의 수신 버퍼에서 제거된다.
    - len : 버퍼에 넣을 수 있는 데이터 크기의 상한선이다.
    - flags 
        - 데이터 수신을 제어하는 비트플래그이다.
        - UDP의 recvfrom()의 flags와 같은 값을 사용할 수 있다.
    - 리턴값 
        - 성공 
            - 수신 성공한 데이터의 길이
            - len보다 작거나 같은 값이 나온다.
        - 실패 : -1
- send()의 len에 0를 넣어 보냈는데 recv()가 0을 리턴되면, 소켓에서 읽을 것이 있다는 뜻이다. 
- 위 방법으로 소켓이 읽은 준비가 되었는지를 확인 해 볼 수 있다.

### 잘형 안전성을 보강한 TCP 소켓